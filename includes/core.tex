% !TeX spellcheck = sk_SK
 


\section{Analýza problému} 

  

\subsection{Petriho siete} % not called Petriflow 

 Carl Adam Petri založil koncept Petriho sietí v roku 1962 vo svojej dizertačnej práci - Komunikácia s Automatmi - na Technickej Univerzite v Darmstadte. Ďalším výskumom sa z pôvodného konceptu ktorý bol určený na modelovanie analýzu komunikačných systémov vyvynul nástroj, ktorý sa používa naprieč monými oblastiami najmä na modelovanie papalelných a distribuovaných systémov. 
 
 Základné Petriho siete pozostávajú z prechodov, miest a hrán. 
 %TODO rozumna definica PN
  
\subsection{Petriflow} % not called Petriflow 
\cite{petriflow_clanok}
Formalizmus Petriflow je rozšírenie Petriho sietí, ktoré bolo navrhnuté na modelovanie komplexných biznisových procesov. Bol vyvinutý Spoločnosťou Netgrif na základe dlhodobých skúseností s klientami, ktorý pomocou tohto formalizmu modelujú svoje biznis procesy, ktoré sú následne zavedené do používania. 
%TODO bleh
%TODO komu dat credit?
%TODO cite diplomka
Formalizmus Petriflow rozširuje Petriho siete o daľsie kompnenty. Ako základ berie Petriho siete obohatené reset, inihibitor a read hrany. Aby sa dali modelovať moderné biznis procesy pridáva Petriflow do tohto modelu roly, dátové polia a akcie. 
Roly definujú kto je oprávnený spúšťať rôzne prechody. 
Dátové polia definujú štruktúru dát ktoré každá inštanica procesu obsahuje počas svojho behu.
Akcie definujú vsťahy a interakcie medzi jednotlivými dátovými poliami a prechodmi.

V klacických petriho sieťach je spustenie prechodu vždy atomická operáci. Petriflow obsahuje 2 typy prechodov udalostné precohdy, ktoré sú rovnako ako v klasických PN sieťach atomické, avšak vždy ich spúšťa nejaká osoba(používaťeľ) v systéme. Druhý typ prechodu je úloha. Úlohu môžeme vnímať ako podsieť na obrázku \ref{task}. Na začiatku je úloha nepridelená, ako prvý krok je potrebné ju niekomu (aj sebe) prideliť. Následne môže toto pridelenie zrušiť, prideliť inej osobe, alebo úlohu dokončiť
%todo - permission to assign/cancel/delegate/finish


\begin{figure}[!htbp]
 	\centering
 	\includegraphics[width=6cm]{img/task_transition.png}
 	\caption{Úloha}
 	\label{task}
\end{figure} 


  

\subsection{Aplikačné rozhranie} 

Majme procesne orientovaný ststém ktorý implementuje procesy, popísane v Petriflow. S takýmto systémom používateľia interagujú iba presne popísaným spôsobom a to spúšťaním prechodov ktoré majú podľa svojich rolí oprávnenie spúšťať (delegovať, dokončiť,... ). Pri dokončení úlohy (prechodu) musí používateľ poskytnúť dáta popísané v dátových poliach. 
Keďže formalizmus Petriflow je schopný takýmto spôsobom popísať všetky interakcie používateľa so systémom je možné na jeho základe vygenerovať aj aplikačné rozhranie. Toto rozhranie sprístupní systém mimo jeho domény, zaručí autorizáciu podľa rolí, poskytne dokumentáciu o svojej štruktúre(a tým pádom aj štruktúre procesu) a zabezpečí validáciu dát, ktoré do systému používateľ odošle.

Ak by rozhranie držalo infromáciu o značkovaní, a teda spustiteľnosti prechodov, mohol by nasať stav kedy aplikačné rozhranie je v stave, ktorý naznačuje, že prechod sa nedá spustiť no procesný server už je v stave, kedy je prechod spustiteľný. Kvôli udržaniu konzistencie dát a predideniu race conditions nemôže aplikačné rozhranie držať informáciu o značkovaní a teda ani spustiteľnosti prechodu.

Aktuálna verzia Petriflow poskytuje relatívne granulárne informácie o autorizácií na vykonávanie akcií pomocou rolí, neobsahuje však introfmáciu o používateľoch ani o tom ktorý používateľ má pridelené aké roly. Na implemetnáciu funkčného aplikačného rozhrania teda bude nutné dorobiť systém ktorý túto informáciu bude obsahovať. 

  
\section{Špecifikácia} 
V tejto kapitole najprv stručne opíšeme hlavnú funkcionalitu navrhovanej aplikácie, potom zadefinujeme funkcionálne a nefunkcionálne požiadavky na aplikáciu. 

Softvér, ktorý sme sa rozhodli implementovať bude slúžiť ako rozhranie medzi procesným serverom a internetom. Bude umožňovať klientovi pripojiť sa na procesný server cez internet, autentifiokvať sa, získať informácie o dátach v prechodoch petriho siete a bude umožňovať modifikovať stav siete (procesu) spúšťaním prechodov. 

  
\subsection{Funkcionálne požiadavky} 

\begin{enumerate} 
    \item Rozhranie bude umožňovať administátorovi registrovať používateľov a priraďovať im roly 
    \item Umožní administrátorovi za behu pridať nové koncevé body a meniť, alebo vymazať aktuálne nasadené koncové body 

    \item Umožní prihlásenie používateľa pomocou štandardného autentifikačného protokolu. 

    \item Autentifikovaným používateľom umožní prístup k dátam z tých prechodov ktoré majú právo čítať podľa ich roly. 

    \item Autentifikovaným používateľom umožní spúšťať prechody ktoré majú právo spúšťať podľa ich roly. 

    \item Pri spúšťaní prechodu prebehne validácia vstupných dát. V prípade nevalidných alebo nekompletných dát nepovolí spustenie prechodu. 

    \item Rozhranie poskytne online dokumentáciu prechodov v sieti, táto dokumentácia bude zahŕňať URL prechodu, potrebné dátové polia na spustenie prechodu a roly, ktoré sú oprávnené prechody spúšťať. 

    \item Rozhranie poskytne aplikačné rozhranie viacerým sieťam s rôznou štruktúrou. A viacerím inštanciám týchto sietí. 
\end{enumerate}     

 

\subsection{Nefunkcionálne požiadavky} 

\begin{enumerate} 
    \item Rozhranie bude škálovateľné 
     
    \item Rozhranie bude zabezpečené štandartnými bezpečnosntými prvkami
    
    \item Rozhranie bude bežať na serveri s operačným systémom Ubuntu 18.04.2 LTS Bionic Beaver poskytnutom Fakultou Elektrotechniky a Informatiky na Slovenskej Technickej Univerzite.  
\end{enumerate} 

  

\section{Návrh} 


% TODO - what have we done in this chapter? 

 

\subsection{Prípady použitia}
Zo špecifikácie vyplývajú nasledovné interakcie používateľa s naším systémom.

\subsubsection{Registrácia koncového bodu}
Prvý prípad použitia \ref{usecase1} je registrácia koncového bodu. Aktér ktorý môže registrovať koncové body je len administrátor. Pri tejto akcií administrátor poskytne nášmu systému informácie o štruktúre procesu vo formáte petriflow, zoznam používateľov im prislúchajúcich rolí v XML a unikátny identifikátor siete. 

Pokial chce administrátor upraviť nadadený proces spustí proces registrácie nanovo s upravenými údajmi o sieti, používateľoch a rolách.

Administrátor taktiež môže sieť vymazať. \ref{usecase1}
\begin{figure}[!htbp]
	\centering
	\includegraphics[width=6cm]{img/dp_usecase_1_register.png}
	\caption{Prípad použitia - Registrácia koncového bodu}
	\label{usecase1}
\end{figure} 

\subsubsection{Získanie informácie o prechode}
Keď už sú sieť aj používateľia úspešne zaregistrovaný, si môžu používatelia, vyžiadať \ref{usecase2} informácie o prechode. Tieto informácie budú poskytnuté len používateľovi s rolou oprávnenou na čítanie dát z daného prechodu.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=6cm]{img/dp_usecase_2_read_run.png}
	\caption{Prípad použitia - Získanie informácií o prechode}
	\label{usecase2}
\end{figure} 

\subsubsection{Spustenie prechodu}
Používateľia s príslušnými rolami môžu taktie spúšťať \ref{usecase2} prechody. Pri spustení prechodu poskytne používateľ dátové polia potrebné na spustenie prechodu. 

\subsubsection{Autentifikácia}
Z požiadavky na bezpečnosť aplikácie vyplýva ešte prípad použitia, kedy sa neautentifikovaný používateľ autentifikuje, aby nadobudol identitu rozpoznanú našim systémom. 



\subsection{Architektúra} 

Aby sme splnili požiadavku na jednoduché škálovanie aplikácie a pre sprehľadnenie architektúry zvolili sme si architektúru mikroservisov. Táto architektúra pozostáva z viacerých oddelených častí, každá z týchto častí má svoju jasne definovanú funkciu. Takéto mikroservisy sú jednoducho testovateľné, dajú sa nasadzovať postupne a nezávisle od seba a softvér navrhnutý v tejto architektúre býva spravidla robustný a vysoko škálovateľný.  

Softvér sa bude skladať z troch hlavných služieb: generátor, koncový bod a autentifikačná služba.
\begin{itemize}
	\item Generátor je služba, ktorá bude registrovať a zostavovať koncové body. Je to služba, na ktoú sa pripojí adiministátor, zadá štruktúru siete a zoznam používateľov a rolí. Táto služba následne zaregistuje používateľov a ich roly, vygeneruje kód pre službu koncového bodu a túto služnu spustí.
	\item Koncový bod je služba, ktorá obsahuje vygenerovaný kód koncových bodov. Táto služba bude poskytovať dokumentáciu dostupných konových bodov. bude poskytovať samotné koncové body aprizavolaní koncového bodu sa bude starať o validáciu prijatých dát.
	\item Autentifikačná služba sa stará o autentifikáciu používateľov a pridelovanie rolí použivateľom
\end{itemize}


\begin{figure}[!htbp]
	\centering
	\includegraphics[width=10cm]{img/architecture.png}
	\caption{Architektúra rozhrania}
	\label{architecture}
\end{figure} 


\section{Implementácia} 

% TODO 

  

\subsection{Použité technológie} 

  

\subsubsection{Kotlin} 

Kotlin je relatívne nový programovací jazyk, projekt Kotlin bol po prvý krát zverejnený v roku 2011 spoločnosťou JetBrains(Andrey Breslav). Bol vyvinutý ako moderný staticky typovaný jazyk, ktorý podporuje rýchlu kompiláciu do javy. V roku 2017 vyhlásil Google podporu pre Kotlin v operačnom systéme Android.  
Medzi jeho hlavné výhody patrí menší boilerplate (menej zbytočného kódu), a vylepšený systém typovania premenných. V Kotline  môžu byť premenné nulovateľné, to znamená, že kompilátor počita s prípadom, že nulovateľná premenná ešte nieje inizcializovaná. Kompilátor Kotlinu využíva pokročilú logiku na to, aby zistil v ktorých vetvách kódu premenné môžu obsahovať null a v ktorých nie. V prípade že podmienkou ošetríme nulový prípad kompilátor v druhej vetve programu zmení typ premennej tak,že už nieje nulovateľná \ref{alg:preview}. Teda v kóde(pokiaľ aktívne neobijdeme typovú ochranu) nemôže nastať null pointer exception.



\begin{lstlisting}[caption={Ukážka funkcie typov v jazyku Kotlin},label={alg:preview},language=Kotlin]

fun maybeGetString():String? // returns null or String

val variable = maybeGetString() //type: String?

variable.length // compilation error

if(variable == null){
	variable = ""
}

variable.length //type: String - OK

\end{lstlisting}


Kotlin je jazyk ktorý sa dá buď transpilovať do jazyka java, alebo JavaScript, alebo sa dá kompilovať priamo do spustiteľného  binárneho súboru
pre všetky bežné Operačné systémy (Linux, Windows, ANdroid, iOS). My budeme používať Korlin kompilovaný do jazyka Java lebo nám to dovoluje využívať vyhody jazyka a zároveň využívať všetky knižnice, ktoré sú dosupné pre jazyk Java.


\subsubsection{Gradle} 

Gradle je voľne šíriteľný nástroj na automatizáciu zostavovania softvéru. Je stavaný na to aby bol schopný zostaviť takmer ľubovoľný program. Podporuje jazyky ako java, C++ Python, a mnoho ďalších. V našom projekte sa gradle použijeme na manažment závislostí, kompiláciu kódu a spustenie samotného skompilovaného programu. Konfigurácia nástroja prebieha pomocou konfiguračného súboru napísaného v jazyku Groovy, tieto konfiguračné  súbory sa v našom prípade použitia ukázali ako veľmi prehľadné a ľahké na použitie. Gradle taktiež používa pokročilú techniku memoizácie procesu zostavovania softvéru takže jeho výkon je pri opakovanej kompilácií vyšší.

 
 
\subsubsection{Spring boot} 

Spring Boot je voľne šíriteľný framework založený na jazyku Java. Je vyvíjaný a udržiavaný tímom Pivotal. Je určený na vytváranie nezávislých, produkčných aplikácií a mikroservisov. Spring boot je robustná platforma so širokou podporou pre všetky štandartné operácie ktoré budeme potreobvať pri vývoji vebového rozhrania. Poskytuje podporu pre vytváranie štandartných RESTful koncových bodov, dalej poskytuje podporu pre štandartnú autentifikáciu pomocou \acrshort{oauth} a integráciu s  openapi 3.0 pomocou balíčka Swagger
%TODO \cite openApi 
%TODO \cite swagger


%Pri práci so Spring boot budeme využívať návrhové vzory: 
%Dependency injection / Inversion of control (Tým že v jednoduchých triedach pridáme anotáciu, vieme z frameworku zdediť nielen funkcie, ale aj control flow)  

%Singleton (aplikácia vie zaručiť že z daného objektu sa v rámci jednej inštancie aplikácie vytvorí len jedna inštancia, ku ktorej sa dá pristupovať z celej aplikácie) 

%Factory 


%TODO initliaizr
 Všetky Spring Boot kontajnery sme inštalovali pomocou spring initializr \cite{initializr}

tento nástroj vygeneruje zip súbor so založeným projektom vo frameworku Spring Boot. Pri vytváraní projektu je možné si vybrať Jazyk v ktorom bude projekt založený a nástroj ktorý bude projekt zostavovať % --


  

\subsubsection{Spring cloud} 

 Spring Cloud je framework, ktorý obsahuje bohatú sadu nástrojov na vytváranie mikroservisov a cloudových riešení. Medzi nástroje Spring Clopudu patí:  

\begin{itemize} 

\item Cloud config - nástroj na distribúciu konfiguračných súborov medzi kontajnermi mikroservisov

\item Service discovery - nástroj na registráciu a monitorovanie mikroservisov 

\item Gateway - Nástroj na routovanie a load balancing v rámci mikroservisov 

\item Cloud Authentication - Nástroj na riešenie komplexnej autentizácie a autorizácie v rámci 

\end{itemize} 


  

\subsection{Generátor} 
\subsubsection{Git}
%todo .gitignore
\subsubsection{Gradle}
\subsubsection{Kotlin poet}


\subsection{Koncový bod}
\subsubsection{Validácia}

\subsection{Autentifikácia}
 
\subsection{Gateway} 




  

 

  

\section{Testovanie} 

 Na testovanie sme použili softvér Insomnia REST Client\cite{insomnia}. Tento program je určený na testovanie REST a GraphQL služieb. Je to voľne šíriteľná alternatíva známeho programu Postman, postavená na platforme Electron s použitím knižnice React. Insomnia nám dovolí vytvoriť a uložiť viacero testovacích dopytov, ktoré môžeme neskôr spustiť a overiť ich správne fungovanie. Insomnia taktiež podporuje autentifikačný protokol OAuth2, takže nám stačí iba zadať prístupové údaje a autorizačný token si stiahne sama. Taktiež v prípade vypršania autorizačného tokenu ho automaticky obnoví. 
 
 Pomocou tohto softvéru sme tesotvali funkcionalitu všetkých servisov.
 %TODO - Ako sme testovali

